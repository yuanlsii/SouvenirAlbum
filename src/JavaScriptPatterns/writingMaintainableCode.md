<h1>如何编写可维护的JavaScript代码</h1>

The Single Responsibility Principle（单一职责SRP）：
    A class should have only one reason to change
    类发生更改的原因应该只有一个
        一、类和函数的责任分离：一个函数应该专注于完成一项具体任务或功能。不要将多个不相关的功能组合到一个类或函数中。这有利于代码的可读性和可维护性。
        二、单一职责的例子：一个常见的例子激素在一个类中处理数据和用户界面交互的逻辑。按照SRP，这两个不同类应该由两个不同的类或函数处理。
        三、类的方法应该只关注一种变化：在一个类方法应该对同一种类型的变化保持关闭，对不同类型变化保持开放。这意味着如果要修改一个类以适应新的需求，应该尽量只修改与这个需求相关的部分，而不是修改整个类。
        四、避免过于臃肿的类：一个类不应该包含大量的方法和属性，而应该被分解为多个小类，每个小类都有自己的单一职责，这有助于代码的可维护性和可测试性。
        五、模块化编程:将代码分解为小的模块或函数，每个模块或函数只负责一个明确定义的任务，这有助于提高代码的可复用性和可测试性。


The Open/Closed Principle（开闭原则OCP）
    Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.
    软件实体（类，模块，方法等等）应当对扩展开放，对修改关闭，即软件实体应当在不修改的前提下扩展。
        一、对拓展开放：当需要引入新的功能或变化时，应该通过添加新的代码或者拓展已有代码来实现，而不是修改已有代码。
        二、对修改关闭：已经存在的代码应该稳定，不应该频繁更改，这样可以避免引入新的问题或者破坏已有功能。
        三、使用抽象和接口：定义抽象类或者接口来定义一组规范，允许新功能通过这些这些规范来扩展现有的代码。这样，已有的代码可以依赖这些抽象而不是具体实现。
        四、使用多态：通过多态，允许子类或不同的实现类提供不同的行为，扩张已有代码。这可以实现在不修改已有代码的情况下引入新的功能。
        五、封装变化：将代码可能发生改变的部分封装在一起，使其易于扩展和修改。这可以通过相关功能放在同一个类或模块中实现。


The Liskov Substitution Principle（里氏替换原则LSP）
    Subtypes must be substitutable for their base types.
    派生类型必须可以替换它的基类型。 
        一、子类必须支持父类的行为：子类应该继承父类的属性和方法，并且在不改变父类行为的情况下，可以新增或修改自己的行为。
        二、不应该破坏父类的不变式：父类可能有一些约束或者不变性，子类不能破坏这些条件。子类可以加强这些条件，但是不能削弱或违反他们。
        三、子类方法参数要比父类方法参数更宽松：子类的方法参数类型可以是父类方法参数类型的子类型（协变性），这意味着子类可以接受更多类型的输入。这确保了子类可以替代父类。
        四、子类不应该抛出比父类更多或者更严重的异常：如果父类的方法没有抛出异常，那么子类也不应该抛出异常。如果父类抛出了异常，子类抛出的异常应该是父类异常的子类或同类型异常。
        五、避免方法重写导致不一致性：子类在重写父类方法时，方法的前置条件（preconditions）不能比父类更严格，后置条件（postconditions）不能比父类更宽松。
        六、理解"is-a"关系：子类和父类之间应该具有“is-a”关系，即子类应该是父类的一种特例。如果这个关系不成立，可能会违反里式替换原则。


The Interface Segregation Principle（接口分离原则ISP）
    Clients should not be forced to depend on methods they do not use.
    不应该强迫客户依赖于它们不用的方法。
    一、接口应该小而专一
    二、不应该强迫客户端实现不需要的方法
    三、避免"fat"接口
    四、使用接口或抽象类来定义接口
    五、客户端不应该依赖于他们不需要的接口


The Dependency Inversion Principle（依赖反转原则DIP）

